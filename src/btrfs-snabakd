#!/usr/bin/env python3

import os
import sys
import signal
import struct
import socket
import pwd
import grp
import traceback

sys.path.insert(0, '/usr/share/btrfs-snabak')
from snabak_modules.constants import *
from snabak_modules.commands import *
from snabak_modules.config import Config


def log(level, txt):
    if level < LOG_4_WARNING:
        f = sys.stderr
    else:
        f = sys.stdout
    lines = txt.split('\n')
    for line in lines:
        print(f"<{level}>{line}", file=f)
    f.flush()


class ConfigurationError(BaseException):
    pass


class ClientConnection:
    def __init__(self, connection):
        self.conn = connection
        creds = connection.getsockopt(socket.SOL_SOCKET, socket.SO_PEERCRED, struct.calcsize('3i'))
        self.pid, self.uid, self.gid = struct.unpack('3i', creds)
        self.username = pwd.getpwuid(self.uid).pw_name

    def cmd_snapshot(self, cmd: Command):
        r = ''
        try:
            for config_name in cmd.config:
                conf = Config(config_name)
                if not conf.loaded:
                    r += f'configuration "{conf.filename}" does not exist or could not be loaded\n'
                    raise ConfigurationError

                self.check_permissions(conf)  # raises PermissionError

                vol = conf.main.volume
                if not os.path.exists(vol):
                    r += f'configured volume path not found: "{vol}"\n'
                    raise ConfigurationError

                snapdir = conf.main.snapshots
                if not os.path.exists(snapdir):
                    r += f'configured snapshot directory not found: "{snapdir}"\n'
                    raise ConfigurationError

                r += f'snapshotting "{config_name}" FIXME: not implemented yet'

            self.reply(ERR_OK, r)

        except ConfigurationError:
            self.reply(ERR_CONFIGURATION, r)

        except PermissionError:
            self.reply(ERR_PERMISSION, r)

    def cmd_backup(self, cmd: Command):
        r = ''
        for config in cmd.config:
            r += f'backupping {config} FIXME: implement this!\n'
        self.reply(ERR_OK, r)

    def parse_command(self, command_json):
        log(LOG_7_DEBUG, f'received: {command_json} from user "{self.username}"')
        cmd = Command.from_json(command_json)
        mapping = {
            "sn": self.cmd_snapshot,
            "ba": self.cmd_backup
        }
        mapping[cmd.cmd](cmd)  # noqa

    def reply(self, exit_code, message):
        r = json.dumps({'exit_code': exit_code, 'message': message.strip()})
        self.conn.sendall(r.encode())

    def check_permissions(self, config):
        if self.uid == 0:
            return

        if self.username in config.main.allowed_users.as_list():
            return

        for group in config.main.allowed_groups.as_list():
            if self.username in grp.getgrnam(group).gr_mem:
                return

        log(LOG_4_WARNING, f'permission denied for user "{self.username}" to use config "{config.name}"')
        raise PermissionError

    def handle(self):
        try:
            args_json = ''
            while True:
                b = self.conn.recv(1).decode()
                if b == '':
                    break
                elif b == chr(0):
                    self.parse_command(args_json)
                    break
                else:
                    args_json += b

        except:  # noqa
            err = "the daemon encountered the following exception:\n\n" \
                  f"{traceback.format_exc()}\nthis is a bug, please report it."
            self.reply(ERR_UNKNOWN_EXCEPTION, err)
            log(LOG_3_ERROR, err)

    def close(self):
        self.conn.close()


def on_term_signal(signum, _frame):
    log(LOG_7_DEBUG, f"received signal: {signum}")
    raise KeyboardInterrupt()


def remove_socket():
    try:
        os.unlink(UNIX_SOCKET)
    except OSError:
        if os.path.exists(UNIX_SOCKET):
            raise


if __name__ == '__main__':
    remove_socket()
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(UNIX_SOCKET)
    os.chmod(UNIX_SOCKET, UNIX_SOCKET_PERMS)
    sock.listen(1)
    signal.signal(signal.SIGTERM, on_term_signal)
    signal.signal(signal.SIGINT, on_term_signal)
    log(LOG_6_INFO, f'listening on {UNIX_SOCKET}')
    try:
        while True:
            conn, client = sock.accept()
            c = ClientConnection(conn)
            c.handle()
            c.close()

    except KeyboardInterrupt:
        pass

    finally:
        sock.close()
        remove_socket()
        log(LOG_6_INFO, 'terminated')
