#!/usr/bin/env python3

import os
import sys
import signal
import struct
import socket
import pwd
import grp
import traceback
import json

sys.path.insert(0, '/usr/share/btrfs-snabak')
from snabak_modules.exceptions import *
from snabak_modules.constants import *
from snabak_modules.commands import Command
from snabak_modules.config import Config


def log(level, txt):
    if level < LOG_4_WARNING:
        f = sys.stderr
    else:
        f = sys.stdout
    lines = txt.split('\n')
    for line in lines:
        print(f"<{level}>{line}", file=f)
    f.flush()


def check_path_or_raise(path, message='path not found: "{}"', error=PathNotFound):
    if not os.path.exists(path):
        raise error(message.format(path))


class ClientConnection:
    def __init__(self, connection):
        self.conn = connection
        creds = connection.getsockopt(socket.SOL_SOCKET, socket.SO_PEERCRED, struct.calcsize('3i'))
        self.pid, self.uid, self.gid = struct.unpack('3i', creds)
        self.username = pwd.getpwuid(self.uid).pw_name

    def cmd_snapshot(self, cmd: Command):
        r = ''
        try:
            for config_name in cmd.config:
                config = Config(config_name)
                r += f'create a new snapshot for configuration "{config.name}"\n'
                if not config.loaded:
                    raise ConfigurationError(f'configuration "{config.name}" can not be found or loaded')

                self.check_allowed_or_raise(config)  # raise PermissionError

                volume = config.main.volume
                check_path_or_raise(volume, 'volume not found: "{}"')  # raise PathNotFound

                check_path_or_raise(config.main.snapshots, 'snapshot directory not found: "{}"')

                snapdir_base = os.path.join(config.main.snapshots, config.name)
                if not os.path.exists(snapdir_base):
                    r += f'creating new empty snapshot directory: "{snapdir_base}"\n'
                    os.mkdir(snapdir_base)

                _, next_number = self.list_existing_snapshots(snapdir_base)
                r += f'snapshotting "{config_name}", snapshot number {next_number}\n'
                snapdir = os.path.join(snapdir_base, str(next_number))
                snapshot_fullpath = os.path.join(snapdir, 'snapshot')
                os.mkdir(snapdir)
                os.system(f'btrfs subvolume snapshot -r "{volume}" "{snapshot_fullpath}"')
                r += 'ok\n'

            self.reply(ERR_OK, r)

        except ConfigurationError as e:
            self.reply(ERR_CONFIGURATION, r + str(e))

        except PathNotFound as e:
            self.reply(ERR_CONFIGURATION, r + str(e))

        except PermissionError as e:
            self.reply(ERR_PERMISSION, r + str(e))

    def cmd_delete(self, cmd: Command):
        r = f'delete snapshot {cmd.number} from configuration "{cmd.config}"\n'
        try:
            config = Config(cmd.config)
            if not config.loaded:
                raise ConfigurationError(f'configuration "{config.name}" can not be found or loaded')

            self.check_allowed_or_raise(config)  # raise PermissionError

            snapdir_base = os.path.join(config.main.snapshots, config.name)
            check_path_or_raise(snapdir_base, 'snapshot directory not found: "{}"')  # raise PathNotFound

            snapdir = os.path.join(snapdir_base, cmd.number)
            check_path_or_raise(snapdir, 'snapshot not found: "{}"')

            snapshot_fullpath = os.path.join(snapdir, 'snapshot')
            r += f'deleting snapshot "{snapshot_fullpath}"\n'
            os.system(f'btrfs subvolume delete "{snapshot_fullpath}"')
            r += f'deleting directory "{snapdir}"\n'
            os.system(f'rm -rf {snapdir}')

            self.reply(ERR_OK, r)

        except ConfigurationError as e:
            self.reply(ERR_CONFIGURATION, r + str(e))

        except PathNotFound as e:
            self.reply(ERR_USAGE, r + str(e))

        except PermissionError as e:
            self.reply(ERR_PERMISSION, r + str(e))

    def cmd_backup(self, cmd: Command):
        r = ''
        for config in cmd.config:
            r += f'backupping {config} FIXME: implement this!\n'
        self.reply(ERR_OK, r)

    def parse_command(self, command_json):
        log(LOG_7_DEBUG, f'received: {command_json} from user "{self.username}"')
        cmd = Command.from_json(command_json)
        mapping = {
            "sn": self.cmd_snapshot,
            "ba": self.cmd_backup,
            "de": self.cmd_delete
        }
        mapping[cmd.cmd](cmd)  # noqa

    def reply(self, exit_code, message):
        r = json.dumps({'exit_code': exit_code, 'message': message.strip()})
        self.conn.sendall(r.encode())

    def list_existing_snapshots(self, path):  # noqa
        _, dirnames, _ = next(os.walk(path))
        numbers = []
        highest = 0
        for n in dirnames:
            try:
                num = int(n)
                numbers.append(num)
                if num > highest:
                    highest = num
            except ValueError:
                pass
        return numbers, highest + 1

    def check_allowed_or_raise(self, config):
        if self.uid == 0:
            return

        if self.username in config.main.allowed_users.as_list():
            return

        for group in config.main.allowed_groups.as_list():
            if self.username in grp.getgrnam(group).gr_mem:
                return

        log(LOG_4_WARNING, f'permission denied for user "{self.username}" to use config "{config.name}"')
        raise PermissionError(f'permission denied for user "{self.username}"')

    def handle(self):
        try:
            args_json = ''
            while True:
                b = self.conn.recv(1).decode()
                if b == '':
                    break
                elif b == chr(0):
                    self.parse_command(args_json)
                    break
                else:
                    args_json += b

        except:  # noqa
            err = "the daemon encountered the following exception:\n\n" \
                  f"{traceback.format_exc()}\nthis is a bug, please report it."
            self.reply(ERR_UNKNOWN_EXCEPTION, err)
            log(LOG_3_ERROR, err)

    def close(self):
        self.conn.close()


def on_term_signal(signum, _frame):
    log(LOG_7_DEBUG, f"received signal: {signum}")
    raise KeyboardInterrupt()


def remove_socket():
    try:
        os.unlink(UNIX_SOCKET)
    except OSError:
        if os.path.exists(UNIX_SOCKET):
            raise


if __name__ == '__main__':
    remove_socket()
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(UNIX_SOCKET)
    os.chmod(UNIX_SOCKET, UNIX_SOCKET_PERMS)
    sock.listen(1)
    signal.signal(signal.SIGTERM, on_term_signal)
    signal.signal(signal.SIGINT, on_term_signal)
    log(LOG_6_INFO, f'listening on {UNIX_SOCKET}')
    try:
        while True:
            conn, client = sock.accept()
            c = ClientConnection(conn)
            c.handle()
            c.close()

    except KeyboardInterrupt:
        pass

    finally:
        sock.close()
        remove_socket()
        log(LOG_6_INFO, 'terminated')
