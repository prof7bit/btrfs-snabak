#!/usr/bin/env python3

import os
import sys
import signal
import struct
import socket
import pwd
import grp
import json
import traceback

sys.path.insert(0, '/usr/share/btrfs-snabak')
from snabak_modules.constants import *


def log(level, txt):
    if level < LOG_4_WARNING:
        f = sys.stderr
    else:
        f = sys.stdout
    lines = txt.split('\n')
    for line in lines:
        print(f"<{level}>{line}", file=f)
    f.flush()


class ClientConnection:
    def __init__(self, connection):
        self.conn = connection
        creds = connection.getsockopt(socket.SOL_SOCKET, socket.SO_PEERCRED, struct.calcsize('3i'))
        self.pid, self.uid, self.gid = struct.unpack('3i', creds)
        self.username = pwd.getpwuid(self.uid).pw_name

    def cmd_snapshot(self, args: dict):
        r = ''
        for config in args["config"]:
            r += f'snapshotting {config} FIXME: implement this!\n'
        self.reply(ERR_OK, r)

    def cmd_backup(self, args: dict):
        r = ''
        for config in args["config"]:
            r += f'backupping {config} FIXME: implement this!\n'
        self.reply(ERR_OK, r)

    def parse_command(self, command_json):
        log(LOG_7_DEBUG, f"received: {command_json}")
        jso = json.loads(command_json)
        {
            "sn": self.cmd_snapshot,
            "ba": self.cmd_backup
        }[jso["cmd"]](jso)  # noqa

    def reply(self, exit_code, message):
        r = json.dumps({'exit_code': exit_code, 'message': message})
        self.conn.sendall(r.encode())

    def is_allowed(self, users, groups):
        if self.username in users.split(','):
            return True

        for group in groups.split(','):
            if self.username in grp.getgrnam(group).gr_mem:
                return True

        return False

    def handle(self):
        try:
            args_json = ''
            while True:
                b = self.conn.recv(1).decode()
                if b == '':
                    break
                elif b == chr(0):
                    self.parse_command(args_json)
                    break
                else:
                    args_json += b

        except:  # noqa
            err = "the daemon encountered the following exception:\n\n" \
                  f"{traceback.format_exc()}\nthis is a bug, please report it."
            self.reply(ERR_UNKNOWN_EXCEPTION, err)
            log(LOG_3_ERROR, err)

    def close(self):
        self.conn.close()


def on_term_signal(signum, _frame):
    log(LOG_7_DEBUG, f"received signal: {signum}")
    raise KeyboardInterrupt()


def remove_socket():
    try:
        os.unlink(UNIX_SOCKET)
    except OSError:
        if os.path.exists(UNIX_SOCKET):
            raise


if __name__ == '__main__':
    remove_socket()
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(UNIX_SOCKET)
    os.chmod(UNIX_SOCKET, UNIX_SOCKET_PERMS)
    sock.listen(1)
    signal.signal(signal.SIGTERM, on_term_signal)
    signal.signal(signal.SIGINT, on_term_signal)
    log(LOG_6_INFO, f'listening on {UNIX_SOCKET}')
    try:
        while True:
            conn, client = sock.accept()
            c = ClientConnection(conn)
            c.handle()
            c.close()

    except KeyboardInterrupt:
        pass

    finally:
        sock.close()
        remove_socket()
        log(LOG_6_INFO, 'terminated')
